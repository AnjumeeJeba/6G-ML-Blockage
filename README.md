# 6G THz Blockage and micromobility detection with machine learning


### 1. Importing Libraries
 ```python
import arff
import torch
import copy
import numpy as np
import pandas as pd
import seaborn as sns
from pylab import rcParams
import matplotlib.pyplot as plt
from matplotlib import rc
from sklearn.model_selection import train_test_split

from torch import nn, optim
import torch.nn.functional as F
```
1. arff: Used to work with datasets in the ARFF format (common in machine learning). Likely, your THz micromobility dataset is in ARFF format.
2. torch: A deep learning library for creating and training neural networks.
3. copy: Allows deep copying of objects. This might be used later for duplicating models, data structures, etc.
4. numpy: Fundamental library for numerical computations.
5. pandas: For handling tabular data in DataFrames.
6. seaborn and matplotlib: Visualization libraries to create graphs and charts.
7. sklearn: Tools for machine learning, including splitting data into training and testing sets.
8. torch.nn, optim, and F: Submodules of PyTorch for defining models (```nn```), optimization (```optim```), and additional utility functions (```F```).


### 2. Matplotlib Inline Configuration
```python
%matplotlib inline
%config InlineBackend.figure_format = 'retina'
```
```%matplotlib inline:``` Ensures that matplotlib plots are displayed directly inside the Jupyter notebook.
```%config InlineBackend.figure_format = 'retina':``` Makes plots rendered in a higher resolution for better clarity.

### 3. Seaborn Plot Style and Palette
```python
sns.set(style='whitegrid', palette='muted', font_scale=1.2)
HAPPY_COLORS_PALETTE = ["#01BEFE", "#FFDD00", "#FF7D00", "#FF006D", "#ADFF02", "#8F00FF"]
sns.set_palette(sns.color_palette(HAPPY_COLORS_PALETTE))
```
**sns.set():** Customizes the appearance of Seaborn plots with:

 ```whitegrid:``` Adds a grid background to plots.
 ```palette='muted':```Sets muted colors as the default palette.
 ```font_scale=1.2:``` Scales up font sizes in plots for better readability.
 
**HAPPY_COLORS_PALETTE:** A custom color palette. These colors will be applied to the plots.

### 4. rcParams for Plot Size
```python
rcParams['figure.figsize'] = 12, 8
```
Configures the default size of all plots to be 12 inches wide and 8 inches tall.

### 5. Setting Random Seed
```python
RANDOM_SEED = 42
np.random.seed(RANDOM_SEED)
torch.manual_seed(RANDOM_SEED)
```
**RANDOM_SEED = 42:** A fixed value for reproducibility. Ensures that results remain consistent across runs.

**np.random.seed():** Seeds the random number generator for NumPy operations.

**torch.manual_seed():** Seeds PyTorch's random number generator.

This ensures deterministic results during training and data preprocessing.

### 6. Output Explanation
```python
output: <torch._C.Generator at 0x10a91bb30>
```
The output <torch._C.Generator at 0x10a91bb30> is generated by the line torch.manual_seed(RANDOM_SEED). Itâ€™s an object that represents the state of PyTorch's random number generator. This is normal and indicates that the seed has been successfully set.

### 7. Importing the ARFF File
```python
import arff

# Load the ARFF file
with open('Train70%alloriginal.arff', 'r') as f:
    train_dataset = arff.load(f)

with open('Test30%alloriginal.arff', 'r') as f:
    test_dataset = arff.load(f)
```
- The ```arff``` library is being used to read ARFF files, which are typically structured data files used in machine learning (e.g., WEKA datasets).
- ```arff.load(f)``` reads and parses the contents of the ARFF file into Python objects.

### 8.Extracting Data and Attributes
```python
train_data = train_dataset['data']
train_attributes = train_dataset['attributes']

test_data = test_dataset['data']
test_attributes = test_dataset['attributes']
```
The ARFF file is a dictionary-like structure with keys like ```data``` and ```attributes```:
```data```: Contains the actual dataset rows (features and labels).
```attributes```: Describes the column names and types in the dataset (e.g., features and labels).
**Printing Data**
Print the first 14 rows of the training data
```python
for row in train_data[:14]:
    print(row)
```
This loop iterates through the first 14 rows of the training data and prints them. From the screenshots, we can see that:
Each row contains numeric values corresponding to the features of a trace.
The last value in each row is a label:
1 indicates oscillation.
2 indicates non-block.

### 9. Loading ARFF Files

